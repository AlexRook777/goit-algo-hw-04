## Висновок

| Алгоритм           | 10 елементів       | 100 елементів      | 1000 елементів     | 10000 елементів    |
|:-------------------|:-------------------|:-------------------|:-------------------|:-------------------|
| insertion_sort     | 0.00003            | 0.00113            | 0.16746            | 26.31145           |
| merge_sort         | 0.00009            | 0.00091            | 0.01400            | 0.21442            |
| sorted             | 0.00001            | 0.00004            | 0.00074            | 0.01043            |

1.  **Сортування вставками (Insertion Sort)** добре працює лише на дуже малих наборах даних (≤100 елементів).
    Його квадратична часова складність (**O(n²)**) робить його непрактичним для більших масивів.

2.  **Сортування злиттям (Merge Sort)** демонструє стабільну продуктивність для всіх розмірів наборів даних з очікуваною складністю **O(n log n)**.
    Однак, він вимагає додаткової пам'яті і не є таким оптимізованим, як вбудоване рішення Python.

3.  **Timsort** (використовується у вбудованих функціях Python `sorted` та `.sort()`) перевершує обидва алгоритми на практиці:
    -   Він поєднує **сортування вставками** (для невеликих послідовностей) та **сортування злиттям** (для більших частин).
    -   Він адаптується до частково відсортованих даних, досягаючи майже **O(n)** у найкращому випадку.
    -   В середньому та на великих наборах даних він стабільно швидший, ніж чисте сортування злиттям.

**Ключовий висновок:**
У реальних програмах на Python розробники покладаються на вбудовані функції `sorted` / `.sort()`, оскільки Timsort є високооптимізованим, адаптивним та ефективним порівняно з реалізованими вручну алгоритмами сортування.